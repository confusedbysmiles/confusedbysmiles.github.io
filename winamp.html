<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio-Reactive Pride Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            cursor: none;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            background: #000;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            z-index: 10;
            transition: opacity 2s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .controls.fade {
            opacity: 0;
        }
        
        .audio-button {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 12px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .audio-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.2);
        }
        
        .audio-button.active {
            background: rgba(0, 255, 100, 0.2);
            border-color: rgba(0, 255, 100, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 100, 0.3);
        }
        
        .audio-level {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .audio-level-bar {
            height: 100%;
            background: linear-gradient(90deg, #e40303, #ff8c00, #ffed00, #008018, #004cff, #732982);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s ease;
        }
        
        .frequency-bars {
            position: absolute;
            top: 100px;
            left: 20px;
            display: flex;
            height: 60px;
            align-items: flex-end;
            opacity: 0.7;
        }
        
        .freq-bar {
            width: 3px;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 1px;
            border-radius: 2px 2px 0 0;
            transition: height 0.1s ease;
        }
        
        .reset-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.2);
        }
        
        .reset-btn:active {
            transform: translateY(0) scale(0.95);
        }
    </style>
</head>
<body>
    <div class="controls" id="controls">
        <div>ðŸŽµ Audio-Reactive Pride Visualizer</div>
        <div style="font-size: 12px; margin-top: 5px;">Move and click to create patterns</div>
        <button class="audio-button" id="audioButton">ðŸŽ¤ Enable Audio Reactivity</button>
        <div class="audio-level">
            <div class="audio-level-bar" id="audioLevelBar"></div>
        </div>
        <div class="frequency-bars" id="frequencyBars"></div>
    </div>
    <button class="reset-btn" onclick="doReset(this)" title="Reset Visualization">ðŸ”„</button>
    <div class="cursor" id="cursor"></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const controls = document.getElementById('controls');
        const cursor = document.getElementById('cursor');
        const audioButton = document.getElementById('audioButton');
        const audioLevelBar = document.getElementById('audioLevelBar');
        const frequencyBars = document.getElementById('frequencyBars');
        
        // Audio variables
        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let frequencyData;
        let audioEnabled = false;
        let audioLevel = 0;
        let bassLevel = 0;
        let midLevel = 0;
        let trebleLevel = 0;
        let beatDetected = false;
        let lastBeatTime = 0;
        
        // Pride colors with more fluid transitions
        const prideColors = [
            [228, 3, 3],     // Red
            [255, 140, 0],   // Orange  
            [255, 237, 0],   // Yellow
            [0, 128, 24],    // Green
            [0, 76, 255],    // Blue
            [115, 41, 130]   // Purple
        ];
        
        let particles = [];
        let flowField = [];
        let time = 0;
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        let hasInteracted = false;
        
        // Create frequency bars
        for (let i = 0; i < 32; i++) {
            const bar = document.createElement('div');
            bar.className = 'freq-bar';
            bar.style.height = '2px';
            frequencyBars.appendChild(bar);
        }
        const freqBarElements = frequencyBars.querySelectorAll('.freq-bar');
        
        // Audio setup
        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.8;
                
                microphone.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                frequencyData = new Uint8Array(bufferLength);
                
                audioEnabled = true;
                audioButton.textContent = 'ðŸ”Š Audio Active';
                audioButton.classList.add('active');
                
                return true;
            } catch (err) {
                console.error('Error accessing microphone:', err);
                audioButton.textContent = 'âŒ Mic Access Denied';
                return false;
            }
        }
        
        // Audio analysis
        function analyzeAudio() {
            if (!audioEnabled || !analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            analyser.getByteTimeDomainData(frequencyData);
            
            // Calculate overall audio level
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            audioLevel = sum / (dataArray.length * 255);
            
            // Calculate frequency bands
            const third = Math.floor(dataArray.length / 3);
            bassLevel = dataArray.slice(0, third).reduce((a, b) => a + b) / (third * 255);
            midLevel = dataArray.slice(third, third * 2).reduce((a, b) => a + b) / (third * 255);
            trebleLevel = dataArray.slice(third * 2).reduce((a, b) => a + b) / (third * 255);
            
            // Simple beat detection
            const currentTime = Date.now();
            if (bassLevel > 0.7 && currentTime - lastBeatTime > 200) {
                beatDetected = true;
                lastBeatTime = currentTime;
            } else {
                beatDetected = false;
            }
            
            // Update UI
            audioLevelBar.style.width = (audioLevel * 100) + '%';
            
            // Update frequency bars
            for (let i = 0; i < Math.min(freqBarElements.length, dataArray.length); i++) {
                const height = (dataArray[i] / 255) * 60;
                freqBarElements[i].style.height = height + 'px';
                const colorIndex = Math.floor((i / freqBarElements.length) * prideColors.length);
                const color = prideColors[colorIndex];
                freqBarElements[i].style.background = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.8)`;
            }
        }
        
        // Audio button click
        audioButton.addEventListener('click', async () => {
            if (!audioEnabled) {
                audioButton.textContent = 'ðŸ”„ Requesting Access...';
                await setupAudio();
            }
        });
        
        // Global reset function
        window.doReset = function(btn) {
            // Clear all particles
            particles = [];
            
            // Clear the canvas completely
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Reset flow field
            initFlowField();
            
            // Reset time
            time = 0;
            
            // Show controls again briefly
            controls.classList.remove('fade');
            setTimeout(() => {
                if (hasInteracted) controls.classList.add('fade');
            }, 2000);
            
            // Visual feedback
            btn.style.transform = 'scale(0.8)';
            setTimeout(() => {
                btn.style.transform = '';
            }, 150);
        };
        
        // Resize canvas to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initFlowField();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Initialize flow field for fluid movement
        function initFlowField() {
            flowField = [];
            const resolution = 20;
            for (let x = 0; x < canvas.width; x += resolution) {
                for (let y = 0; y < canvas.height; y += resolution) {
                    flowField.push({
                        x: x,
                        y: y,
                        angle: Math.random() * Math.PI * 2,
                        force: Math.random() * 0.5 + 0.1
                    });
                }
            }
        }
        
        // Particle class for fluid effects
        class FluidParticle {
            constructor(x, y, colorIndex = null, audioInfluenced = false) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1;
                this.maxLife = 3 + Math.random() * 4;
                this.size = Math.random() * 3 + 1;
                this.colorIndex = colorIndex !== null ? colorIndex : Math.floor(Math.random() * prideColors.length);
                this.trail = [];
                this.trailLength = 15 + Math.random() * 10;
                this.originalSize = this.size;
                this.phase = Math.random() * Math.PI * 2;
                this.audioInfluenced = audioInfluenced;
                this.bassResponse = Math.random();
                this.midResponse = Math.random();
                this.trebleResponse = Math.random();
            }
            
            update() {
                // Audio-influenced modifications
                let audioMultiplier = 1;
                let sizeMultiplier = 1;
                
                if (audioEnabled && this.audioInfluenced) {
                    // Different particles respond to different frequency ranges
                    if (this.bassResponse > 0.7) {
                        audioMultiplier += bassLevel * 3;
                        sizeMultiplier += bassLevel * 2;
                    }
                    if (this.midResponse > 0.7) {
                        audioMultiplier += midLevel * 2;
                        this.colorIndex = Math.floor(midLevel * prideColors.length) % prideColors.length;
                    }
                    if (this.trebleResponse > 0.7) {
                        audioMultiplier += trebleLevel * 1.5;
                        this.trailLength = Math.max(5, 25 * trebleLevel);
                    }
                    
                    // Beat detection creates bursts
                    if (beatDetected) {
                        this.vx += (Math.random() - 0.5) * 5;
                        this.vy += (Math.random() - 0.5) * 5;
                    }
                }
                
                // Flow field influence (modified by audio)
                const flowX = Math.floor(this.x / 20) * 20;
                const flowY = Math.floor(this.y / 20) * 20;
                const flow = flowField.find(f => f.x === flowX && f.y === flowY);
                
                if (flow) {
                    const flowForce = flow.force * audioMultiplier;
                    this.vx += Math.cos(flow.angle + time * 0.01) * flowForce * 0.1;
                    this.vy += Math.sin(flow.angle + time * 0.01) * flowForce * 0.1;
                }
                
                // Mouse attraction
                if (isMouseDown) {
                    const dx = mouseX - this.x;
                    const dy = mouseY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                        const force = (200 - dist) / 200 * 0.5 * audioMultiplier;
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }
                
                // Add some turbulence (enhanced by audio)
                const turbulence = 0.1 * audioMultiplier;
                this.vx += Math.sin(time * 0.01 + this.phase) * turbulence;
                this.vy += Math.cos(time * 0.015 + this.phase) * turbulence;
                
                // Damping
                this.vx *= 0.98;
                this.vy *= 0.98;
                
                // Store trail
                this.trail.push({ x: this.x, y: this.y, life: this.life });
                if (this.trail.length > this.trailLength) {
                    this.trail.shift();
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Wrap around edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
                
                // Update life and size (modified by audio)
                this.life -= 1 / (this.maxLife * 60);
                this.size = this.originalSize * (0.5 + Math.sin(time * 0.05 + this.phase) * 0.5) * this.life * sizeMultiplier;
                
                return this.life > 0;
            }
            
            draw() {
                if (this.life <= 0) return;
                
                const color = prideColors[this.colorIndex];
                let alpha = this.life;
                
                // Audio enhances brightness
                if (audioEnabled && this.audioInfluenced) {
                    alpha *= (1 + audioLevel);
                }
                
                // Draw trail with gradient
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const segment = this.trail[i];
                    const nextSegment = this.trail[i + 1];
                    const trailAlpha = (i / this.trail.length) * alpha * 0.8;
                    
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${trailAlpha})`;
                    ctx.lineWidth = (i / this.trail.length) * this.size * 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y);
                    ctx.lineTo(nextSegment.x, nextSegment.y);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw particle with glow
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                
                // Outer glow (enhanced by audio)
                const glowSize = this.size * 4 * (audioEnabled ? 1 + audioLevel : 1);
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.8})`);
                gradient.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha * 0.3})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Core particle
                ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Mouse movement tracking
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            // Update custom cursor
            cursor.style.left = (mouseX - 10) + 'px';
            cursor.style.top = (mouseY - 10) + 'px';
            
            // Add particles on mouse move
            if (hasInteracted && Math.random() < 0.3) {
                for (let i = 0; i < 2; i++) {
                    const offsetX = mouseX + (Math.random() - 0.5) * 50;
                    const offsetY = mouseY + (Math.random() - 0.5) * 50;
                    particles.push(new FluidParticle(offsetX, offsetY, null, true));
                }
            }
        });
        
        // Mouse click events
        document.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            hasInteracted = true;
            
            // Create burst of particles
            const burstSize = audioEnabled ? 20 + Math.floor(audioLevel * 30) : 20;
            for (let i = 0; i < burstSize; i++) {
                const angle = (i / burstSize) * Math.PI * 2;
                const velocity = 2 + Math.random() * 3 + (audioEnabled ? audioLevel * 5 : 0);
                const x = mouseX + Math.cos(angle) * Math.random() * 30;
                const y = mouseY + Math.sin(angle) * Math.random() * 30;
                const particle = new FluidParticle(x, y, null, true);
                particle.vx = Math.cos(angle) * velocity;
                particle.vy = Math.sin(angle) * velocity;
                particles.push(particle);
            }
            
            // Hide controls after first interaction
            if (controls.style.opacity !== '0') {
                setTimeout(() => controls.classList.add('fade'), 3000);
            }
        });
        
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        
        // Animation loop
        function animate() {
            // Analyze audio
            analyzeAudio();
            
            // Create trailing effect (modified by audio)
            const fadeAmount = audioEnabled ? 0.02 + (audioLevel * 0.05) : 0.02;
            ctx.fillStyle = `rgba(0, 0, 0, ${fadeAmount})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            time++;
            
            // Update flow field (audio influences rotation speed)
            const flowSpeed = audioEnabled ? 0.01 + (audioLevel * 0.02) : 0.01;
            flowField.forEach(flow => {
                flow.angle += Math.sin(time * flowSpeed + flow.x * 0.01 + flow.y * 0.01) * 0.02;
            });
            
            // Update and draw particles
            particles = particles.filter(particle => {
                const alive = particle.update();
                if (alive) particle.draw();
                return alive;
            });
            
            // Add ambient particles (more with audio)
            const maxParticles = audioEnabled ? 500 + Math.floor(audioLevel * 200) : 500;
            const spawnRate = audioEnabled ? 0.1 + (audioLevel * 0.3) : 0.1;
            
            if (hasInteracted && particles.length < maxParticles && Math.random() < spawnRate) {
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                switch (edge) {
                    case 0: x = Math.random() * canvas.width; y = 0; break;
                    case 1: x = canvas.width; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height; break;
                    case 3: x = 0; y = Math.random() * canvas.height; break;
                }
                particles.push(new FluidParticle(x, y, null, true));
            }
            
            // Beat-driven particle bursts
            if (beatDetected && hasInteracted) {
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const particle = new FluidParticle(x, y, Math.floor(Math.random() * prideColors.length), true);
                    particle.vx = (Math.random() - 0.5) * 10;
                    particle.vy = (Math.random() - 0.5) * 10;
                    particles.push(particle);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Initialize with some particles for demo
        setTimeout(() => {
            if (!hasInteracted) {
                for (let i = 0; i < 50; i++) {
                    particles.push(new FluidParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        null,
                        false
                    ));
                }
            }
        }, 2000);
    </script>
</body>
</html>
